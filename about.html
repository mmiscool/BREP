<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>About BREP</title>
<style>
:root{
  --bg:#0b0f14; --panel:#0f141b; --text:#d7dde6; --muted:#9aa7b2;
  --border:#1b2430; --accent:#5cc8ff; --chip:#121823;
}
*{box-sizing:border-box}
html,body{margin:0;background:var(--bg);color:var(--text);font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial}
main{max-width:1100px;margin:0 auto;padding:28px}
h1{margin:0 0 18px;font-size:22px;color:var(--accent);font-weight:700}
.summary{color:var(--muted);margin-bottom:22px}
.card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:18px;margin:0 0 18px}
.readme{padding:0}
.readme .header{padding:16px 18px;border-bottom:1px solid var(--border)}
.readme .content{padding:18px}
.prose h1{font-size:24px;margin:0 0 12px}
.prose h2{font-size:18px;margin:18px 0 8px}
.prose h3{font-size:16px;margin:14px 0 6px}
.prose p{margin:0 0 10px}
.prose ul{margin:0 0 10px 18px}
.prose li{margin:4px 0}
.prose code{background:#0d1520;border:1px solid var(--border);padding:1px 5px;border-radius:6px;font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}
.prose pre{background:#0d1520;border:1px solid var(--border);padding:12px;border-radius:12px;overflow:auto}
.prose a{color:var(--accent)}
.license{
  background:var(--panel);border:1px solid var(--border);border-radius:14px;
  padding:16px 16px 8px;margin:0 0 18px;
}
.license > h2{margin:0 0 10px;font-size:16px;font-weight:700}
.pkg{
  border-top:1px solid var(--border);padding:10px 0;
  display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;
}
.pkg:first-of-type{border-top:none}
.pkg .meta{display:flex;gap:10px;flex-wrap:wrap}
.pkg .name{font-weight:600}
.pkg .desc{color:var(--muted);margin-top:2px}
a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
.chip{background:var(--chip);border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px;color:var(--muted)}
.footer{margin-top:26px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<main>
  <section class="card readme">
    <div class="header"><h1>Project Overview</h1></div>
    <div class="content prose"><h1>BREP</h1><p>A feature-based modeling playground experimenting with BREP-style workflows on top of triangle meshes. It combines robust manifold CSG (via the <a href="https://github.com/elalish/manifold/">Manifold</a> library) with a simple face/edge representation, a history pipeline, and Three.js visualization. Import meshes (STL), repair and group them into faces, then perform boolean operations, fillets, chamfers, sweeps, lofts, and more.</p><p>This project is actively evolving; expect rough edges while APIs settle.</p><h2>Highlights</h2><ul><li>Feature history pipeline with a compact UI to add, edit, and re-run features.</li><li>Robust CSG powered by <code>manifold-3d</code> with face-label provenance carried through booleans.</li><li>Mesh-to-BREP conversion that groups triangles into faces by normal deflection.</li><li>Mesh repair pipeline: weld, T‑junction fix, overlap removal, hole fill, and consistent normals.</li><li>Importers for both STL (using Three.js loaders).</li><li>Primitive solids (cube, sphere, cylinder, cone, torus, pyramid) and typical CAD features (sketch/extrude, sweep, loft, revolve, fillet, chamfer, mirror, boolean ops).</li><li>Modular main toolbar with: Save, Zoom to Fit, Wireframe toggle, About, and STL export.</li><li>Selection Filter surfaced in the toolbar for quick access.</li><li>Browser test runner captures per-test canvas snapshots (with auto Zoom‑to‑Fit) and shows them in the log dialog.</li></ul><h2>Features Status</h2><ul><li>Primitive Cube: Implemented</li><li>Primitive Cylinder: Implemented</li><li>Primitive Cone: Implemented</li><li>Primitive Sphere: Implemented</li><li>Primitive Torus: Implemented</li><li>Primitive Pyramid: Implemented</li><li>Plane: Implemented</li><li>Datium: Planned</li><li>Sketch: Planned</li><li>Extrude: Implemented</li><li>Sweep: Work in progress</li><li>Loft: Planned</li><li>Revolve: Planned</li><li>Mirror: Implemented</li><li>Boolean: Implemented</li><li>Fillet: Implemented</li><li>Chamfer: Implemented</li><li>STL Import: Implemented</li></ul><h2>Getting Started</h2><p>Prereqs: Node.js 18+ and <code>pnpm</code> installed.</p><ul><li>Install dependencies: <code>pnpm install</code></li><li>Run dev server (Vite): <code>pnpm dev</code></li><p>- Open the printed URL (usually http://localhost:5173). Try <code>index.html</code>, <code>sdf.html</code>, or <code>offsetSurfaceMeshTest.html</code> for sandboxes.</p><li>Run tests: <code>pnpm test</code></li><li>Live testing while editing (Node): <code>pnpm liveTesting</code></li></ul><h3>UI overview (browser)</h3><ul><li>Top toolbar (fixed):</li><p>- Save: stores the current model to browser localStorage (integrates with File Manager). - Zoom to Fit: pans and zooms using ArcballControls to frame all visible geometry without changing orientation. - Wireframe: toggles mesh wireframe rendering for a quick inspection. - About: opens the third‑party license report. - Export STL: downloads an ASCII STL of the current part(s). If multiple solids are present, you can export each individually. If you have solids selected, only the selected ones are exported.</p><li>Selection Filter: now lives in the toolbar (right side) for quick changes; Esc clears selection.</li></ul><h2>Importing Models (STL and 3MF)</h2><p>Use the “STL Import” feature in the history panel. It now supports both STL and 3MF:</p><ul><li>STL: ASCII or binary. Parsed with <code>three/examples/jsm/loaders/STLLoader.js</code>.</li></ul><p>After parsing, an optional centering step runs, followed by the mesh repair pipeline (configurable levels). Finally, triangles are labeled into faces by deflection angle and authored into a <code>Solid</code> for CSG and visualization.</p><p>Programmatic example (from tests):</p><p><pre><code>import { PartHistory } from &#39;./src/PartHistory.js&#39;;

const ph = new PartHistory();
const importFeature = await ph.newFeature(&#39;STL&#39;); // also accepts 3MF
importFeature.inputParams.fileToImport = someStlOr3mfData; // string (ASCII or data URL) or ArrayBuffer
importFeature.inputParams.deflectionAngle = 15; // degrees to group triangles into faces
await ph.runHistory();</code></pre></p><h2>How It Works</h2><ul><li><code>Solid</code> authoring uses arrays (triangles + per‑triangle face labels). Before building a Manifold, triangle windings are made consistent and orientation is fixed by signed volume.</li><li><code>manifold-3d</code> creates a robust manifold and propagates face IDs through CSG, so original face labels remain usable after unions/differences/intersections.</li><li>Faces and edges are visualized via Three.js; face names remain accessible for downstream feature logic.</li></ul><h2>BREP Model and Classes</h2><ul><li><strong>BREP model:</strong> Triangle mesh plus per‑triangle face labels. Labels map to globally unique IDs in Manifold, which propagate through CSG so selections remain stable. Edges are derived at boundaries between distinct face labels and represented as polyline chains.</li><li><strong>Manifoldization:</strong> Authoring arrays are cleaned before build: triangle windings are made consistent by adjacency; outward orientation is enforced by signed volume; an optional weld epsilon removes duplicate vertices and degenerates. Results are cached until geometry mutates.</li><li><strong>Visualization:</strong> <code>Solid.visualize()</code> creates one <code>Face</code> mesh per face label and <code>Edge</code> polylines for label boundaries. Objects include semantic names to support selection and downstream features.</li></ul><h3>Solid</h3><ul><li><strong>Type:</strong> <code>THREE.Group</code> subclass providing authoring, CSG, queries, and export.</li><li><strong>Geometry storage:</strong> <code>_vertProperties</code> (flat positions), <code>_triVerts</code> (triangle indices), <code>_triIDs</code> (per‑triangle face ID), with name↔ID maps to preserve labels through CSG.</li></ul><ul><li><code>addTriangle(faceName, v1, v2, v3)</code>: Adds a labeled triangle; inputs <code>faceName:string</code>, <code>v1:[x,y,z]</code>, <code>v2:[x,y,z]</code>, <code>v3:[x,y,z]</code>; returns <code>Solid</code> (this).</li><li><code>setEpsilon(epsilon = 0)</code>: Sets weld tolerance, welds vertices, drops degenerates, fixes windings; inputs <code>epsilon:number</code>; returns <code>Solid</code> (this).</li><li><code>mirrorAcrossPlane(point, normal)</code>: Returns a mirrored copy across a plane; inputs <code>point:THREE.Vector3|[x,y,z]</code>, <code>normal:THREE.Vector3|[x,y,z]</code>; returns <code>Solid</code>.</li><li><code>invertNormals()</code>: Flips triangle windings to invert normals; inputs none; returns <code>Solid</code> (this).</li><li><code>fixTriangleWindingsByAdjacency()</code>: Enforces consistent orientation across shared edges; inputs none; returns <code>Solid</code> (this).</li><li><code>removeTinyBoundaryTriangles(areaThreshold, maxIterations = 1)</code>: Removes sliver triangles along label boundaries via safe 2–2 flips; inputs <code>areaThreshold:number</code>, <code>maxIterations?:number</code>; returns <code>number</code> (flips performed).</li><li><code>getMesh()</code>: Gets current Manifold MeshGL; inputs none; returns <code>MeshGL</code> (<code>{ numProp, vertProperties, triVerts, faceID, ... }</code>).</li><li><code>getFace(name)</code>: Fetches triangles for a face label; inputs <code>name:string</code>; returns <code>Array&lt;{ faceName, indices:number[], p1:[x,y,z], p2:[x,y,z], p3:[x,y,z] }&gt;</code>.</li><li><code>getFaces(includeEmpty = false)</code>: Enumerates faces and their triangles; inputs <code>includeEmpty?:boolean</code>; returns <code>Array&lt;{ faceName:string, triangles:Triangle[] }&gt;</code>.</li><li><code>getFaceNames()</code>: Lists known face labels; inputs none; returns <code>string[]</code>.</li><li><code>getBoundaryEdgePolylines()</code>: Computes boundary polylines between distinct face labels; inputs none; returns <code>Array&lt;{ name:string, faceA:string, faceB:string, indices:number[], positions:[x,y,z][], closedLoop?:boolean }&gt;</code>.</li><li><code>visualize(options = {})</code>: Builds per‑face meshes and edge polylines into this group; inputs <code>options:{ showEdges?:boolean, materialForFace?:(name)=&gt;Material, name?:string }</code>; returns <code>Solid</code> (this).</li><li><code>union(other)</code>: Boolean union; inputs <code>other:Solid</code>; returns <code>Solid</code>.</li><li><code>subtract(other)</code>: Boolean difference (A − B); inputs <code>other:Solid</code>; returns <code>Solid</code>.</li><li><code>intersect(other)</code>: Boolean intersection; inputs <code>other:Solid</code>; returns <code>Solid</code>.</li><li><code>difference(other)</code>: Boolean difference via Manifold API; inputs <code>other:Solid</code>; returns <code>Solid</code>.</li><li><code>simplify(tolerance?)</code>: Simplifies mesh preserving label boundaries; inputs <code>tolerance?:number</code>; returns <code>Solid</code>.</li><li><code>setTolerance(tolerance)</code>: Sets manifold tolerance (may simplify); inputs <code>tolerance:number</code>; returns <code>Solid</code>.</li><li><code>volume()</code>: Computes enclosed volume; inputs none; returns <code>number</code>.</li><li><code>surfaceArea()</code>: Computes total surface area; inputs none; returns <code>number</code>.</li><li><code>toSTL(name = &#39;solid&#39;, precision = 6)</code>: Exports ASCII STL; inputs <code>name?:string</code>, <code>precision?:number</code>; returns <code>string</code> (STL text).</li><li><code>writeSTL(filePath, name = &#39;solid&#39;, precision = 6)</code>: Writes ASCII STL to disk (Node only); inputs <code>filePath:string</code>, <code>name?:string</code>, <code>precision?:number</code>; returns <code>Promise&lt;string&gt;</code> (path written).</li></ul><h3>Face</h3><ul><li><strong>Type:</strong> <code>THREE.Mesh</code> representing all triangles that share a face label (can be non‑planar or disjoint islands).</li><li><strong>Properties:</strong> <code>name</code> (label), <code>type</code> = <code>FACE</code>, <code>edges</code> (adjacent <code>Edge</code> objects), <code>geometry</code> (per‑face BufferGeometry built by <code>visualize()</code>).</li></ul><ul><li><code>getAverageNormal()</code>: Computes area‑weighted world‑space average normal; inputs none; returns <code>THREE.Vector3</code>.</li><li><code>surfaceArea()</code>: Computes world‑space surface area; inputs none; returns <code>number</code>.</li></ul><h3>Edge</h3><ul><li><strong>Type:</strong> <code>Line2</code> polyline representing a boundary chain between two face labels.</li><li><strong>Properties:</strong> <code>name</code> (boundary name), <code>type</code> = <code>EDGE</code>, <code>faces</code> (the two adjacent <code>Face</code> objects when present), <code>closedLoop</code> (boolean), <code>userData.polylineLocal</code> (polyline points), <code>userData.faceA/faceB</code> (label names).</li></ul><ul><li><code>length()</code>: Computes world‑space polyline length; inputs none; returns <code>number</code>.</li></ul><h3>How the BREP Works Here</h3><ul><li><strong>Label‑driven topology:</strong> Faces are semantic groups defined at authoring/import time and tracked per triangle. After booleans, label provenance survives so selections can continue to target the same named faces/edges.</li><li><strong>Edges from labels:</strong> Boundary edges are computed between triangles of different labels, then chained into polylines per label pair. This avoids fragile edge reconstruction and remains stable across many operations.</li><li><strong>Manifold contract:</strong> Inputs are assumed (or repaired to) be closed, watertight 2‑manifolds. The system corrects orientation and coherency but cannot heal gross self‑intersections or missing surfaces.</li></ul><h2>Topological Naming</h2><p>Topological naming is about keeping stable references to faces and edges as the model recomputes. This project uses per‑triangle face labels that propagate through CSG so features can reliably refer to geometry across edits.</p><ul><li>Face labels: Triangles are authored with a string face name. Internally each name maps to a globally unique Manifold ID and is stored as <code>faceID</code> per triangle. After boolean ops, Manifold preserves these IDs so the original face names remain available on the result.</li><li>Edge identification: Edges are computed as polylines along boundaries between pairs of face labels. Each boundary chain is named <code>&lt;faceA&gt;|&lt;faceB&gt;[i]</code>, where <code>i</code> disambiguates multiple loops between the same two faces.</li><li>Selections: The UI stores object names in feature parameters. Because face/edge objects are rebuilt from the propagated labels, references stay stable so long as some triangles of that face survive.</li><li>Primitive conventions: Built‑in primitives assign semantic face names, e.g. <code>Cube_NX/PX/NY/PY/NZ/PZ</code>, <code>Cylinder_S</code> (side), <code>Cylinder_T/B</code> (top/bottom), <code>Torus_Side/Cap0/Cap1</code>. Imported meshes use <code>STL_FACE_&lt;n&gt;</code> groups derived by normal‑deflection clustering.</li><li>Feature‑generated names: Operations derive clear, persistent names. For example, Fillet uses <code>FILLET_&lt;faceA&gt;|&lt;faceB&gt;_ARC</code>, <code>_SIDE_A</code>, <code>_SIDE_B</code>, <code>_CAP0</code>, <code>_CAP1</code>; Chamfer uses <code>CHAMFER_&lt;faceA&gt;|&lt;faceB&gt;_BEVEL</code>, <code>_SIDE_A</code>, <code>_SIDE_B</code>, <code>_CAP0</code>, <code>_CAP1</code>.</li></ul><p>Guidelines and limitations</p><ul><li>Stability: Names persist through booleans and simplification; a name disappears only if all its triangles are removed by subsequent features.</li><li>Splits/merges: A single face name can represent multiple disjoint islands after CSG. Edge loop indices <code>[i]</code> can change when topology changes; avoid hard‑coding the index when possible.</li><li>Semantics vs geometry: Faces are label‑based, not re‑fitted analytic surfaces. Prefer selecting faces by their semantic names (from primitives or earlier features) rather than by geometric predicates alone.</li><li>Authoring tips: When creating new solids or tools, choose descriptive face names and reuse source face names in derived outputs. This improves reference stability for downstream features.</li></ul><p>Roadmap</p><ul><li>Optional GUIDs for selection sets to further reduce ambiguity when faces split.</li><li>Enhanced matching heuristics (geometric signatures) to map selections across parameter changes that substantially remesh surfaces.</li></ul><h2>Key Libraries</h2><ul><li>Three.js (<code>three</code>): rendering and core geometry types.</li><p>- STL loader: <code>three/examples/jsm/loaders/STLLoader.js</code> - 3MF loader: <code>three/examples/jsm/loaders/3MFLoader.js</code> - Geometry utilities: <code>three/examples/jsm/utils/BufferGeometryUtils.js</code></p><li>Manifold (<code>manifold-3d</code>): WASM CSG/mesh library used for manifold construction, boolean operations, and mesh queries. Repo: https://github.com/elalish/manifold/</li><p>- Loaded via <code>src/BREP/setupManifold.js</code> with <code>vite-plugin-wasm</code> in the browser.</p><li>Vite (<code>vite</code>): dev server and build tooling.</li><li>Nodemon (<code>nodemon</code>): convenient live testing for Node-based checks.</li></ul><h2>Project Structure</h2><ul><li><code>src/features/</code> — Implementations of features (primitives, boolean, fillet, chamfer, sketch/extrude, sweep, loft, revolve, STL/3MF import, etc.).</li><li><code>src/BREP/</code> — Core BREP/solid authoring on top of Manifold, mesh repair, mesh-to-BREP conversion.</li><li><code>src/UI/</code> — Minimal UI widgets for the history pipeline and file management.</li><li><code>src/FeatureRegistry.js</code> — Registers features available to the pipeline.</li><li><code>src/PartHistory.js</code> — Orchestrates feature execution and artifact lifecycle.</li><li><code>index.html</code>, <code>sdf.html</code>, <code>offsetSurfaceMeshTest.html</code> — Standalone sandboxes and demos.</li></ul><h2>Scripts</h2><ul><li><code>pnpm dev</code> — Run Vite dev server.</li><li><code>pnpm build</code> — Build for production.</li><li><code>pnpm test</code> — Run test suite.</li><li><code>pnpm liveTesting</code> — Auto-runs tests on file changes.</li></ul><p>The project also includes a simple license report generator (<code>pnpm generateLicenses</code>) that writes <code>about.html</code>.</p><h2>Browser Test Runner</h2><ul><li>A lightweight runner UI (mounted in the browser) lists all tests with controls to run individually or in sequence.</li><li>After each test completes, the runner performs Zoom‑to‑Fit and captures a canvas snapshot. Clicking “Show Log” displays the snapshot above any logged output for that test.</li><li>Between tests, an optional popup can show a running gallery of snapshots when auto‑progressing.</li></ul><h2>Camera Zoom‑to‑Fit</h2><ul><li>Zoom‑to‑Fit uses ArcballControls only (pan + orthographic zoom) to frame all visible geometry while preserving the current camera orientation.</li><li>It computes a bounding box of scene content (excluding Arcball gizmos), projects to camera space to consider the current view, and determines the required zoom so both width and height fit with a small margin.</li><li>No direct camera frustum or orientation changes are applied — this keeps controls and rendering in sync and avoids “jump” artifacts.</li></ul><h2>Status and Limitations</h2><ul><li>Mesh repair is heuristic and may need tuning for specific models.</li><li>3MF: geometry is merged into one mesh; materials/textures are not preserved for editing (visualization only).</li><li>APIs and file formats are subject to change as the project evolves.</li></ul><h2>License</h2><p>See <code>LICENSE.md</code>. This project uses a dual-licensing strategy managed by Autodrop3d LLC.</p></div>
  </section>

  <section class="card">
    <h1>This project's license</h1>
    <div style="white-space: pre-wrap;">Copyright 2025 Autodrop3d LLC
https://autodrop3d.com

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, subject to the following conditions:

Any modifications made to the software must be submitted to Autodrop3d LLC with an irrevocable assignment of the copyright
via git pull request. This is intended to allow Autodrop3d LLC to sell commercial licenses of the software for use
in proprietary products under a dual-licensing strategy. Failure to contribute back modifications without a commercial
license purchased from Autodrop3d LLC voids all permissions granted by this license.
Please visit https://www.autodrop3d.com/ip-licensing.html if you are interested in a commercial license that omits
this condition&#39;s requirement of upstreaming of modifications.

The above copyright notice and these permission notices shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS
OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT
OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</div>
  </section>

  <h1>Licenses Report of libraries used in this package</h1>
  <div class="summary">2 packages • 2 license types</div>
<section class="license">
    <h2>Apache-2.0 <span class="chip">1 package</span></h2>
  <div class="pkg">
      <div>
        <div class="name">manifold-3d <span class="chip">1 version</span></div>
        <div class="desc">Geometry library for topological robustness</div>
        
      </div>
      <div class="meta">
        <a class="chip" href="https://github.com/elalish/manifold#readme" target="_blank" rel="noopener noreferrer">Repo / Homepage</a>
      </div>
    </div></section><section class="license">
    <h2>MIT <span class="chip">1 package</span></h2>
  <div class="pkg">
      <div>
        <div class="name">three <span class="chip">1 version</span></div>
        <div class="desc">JavaScript 3D library</div>
        <div class="desc">Author: mrdoob</div>
      </div>
      <div class="meta">
        <a class="chip" href="https://threejs.org/" target="_blank" rel="noopener noreferrer">Repo / Homepage</a>
      </div>
    </div></section>
  <div class="footer">Generated from <code>pnpm licenses list --prod --long --json</code></div>
</main>
</body>
</html>